{"input": "What does the following code do?\n\nimport { createApp } from 'vue'\nimport { createPinia } from 'pinia'\nimport App from './App.vue'\nimport './styles/main.css'\nimport './styles/glossy.css'\nimport './assets/tool-cursors.css'\n\nconst app = createApp(App)\nconst pinia = createPinia()\napp.use(pinia)\napp.mount('#app')", "output": "This code is from `main.js`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'AddPageDialog',\n  props: {\n    show: { type: Boolean, default: false },\n    initialData: {\n      type: Object,\n      default: () => ({\n        name: '',\n        type: 'foreground',\n        backgroundPageId: '',\n        description: '',\n        drawingType: 'default'\n      })\n    },\n    backgroundPages: { type: Array, default: () => [] },\n    isDarkTheme: { type: Boolean, default: false }\n  },\n  data() {\n    return {\n      pageData: { ...this.initialData }\n    };\n  },\n  watch: {\n    initialData: {\n      handler(newVal) {\n        this.pageData = { ...newVal };\n      },\n      deep: true\n    }\n  },\n  methods: {\n    addPage() {\n      if (!this.pageData.name.trim()) {\n        alert('Page name cannot be empty');\n        return;\n      }\n      this.$emit('add', { ...this.pageData });\n      this.$emit('close');\n    }\n  }\n};", "output": "This code is from `AddPageDialog.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'Calculator',\n  props: {\n    initialPosition: {\n      type: Object,\n      default: () => ({ x: 100, y: 100 })\n    }\n  },\n  data() {\n    return {\n      display: '0',\n      expression: '',\n      lastResult: null,\n      waitingForOperand: false,\n      position: this.initialPosition,\n      isDragging: false,\n      dragOffset: { x: 0, y: 0 }\n    };\n  },\n  methods: {\n    addDigit(digit) {\n      if (this.waitingForOperand) {\n        this.display = digit;\n        this.waitingForOperand = false;\n      } else {\n        this.display = this.display === '0' ? digit : this.display + digit;\n      }\n    },\n    addDecimal() {\n      if (this.waitingForOperand) {\n        this.display = '0.';\n        this.waitingForOperand = false;\n      } else if (this.display.indexOf('.') === -1) {\n        this.display += '.';\n      }\n    },\n    addOperator(operator) {\n      const value = parseFloat(this.display);\n      \n      if (this.lastResult === null) {\n        this.lastResult = value;\n      } else if (!this.waitingForOperand) {\n        this.calculate();\n        this.lastResult = parseFloat(this.display);\n      }\n      \n      this.expression = this.lastResult + ' ' + operator + ' ';\n      this.waitingForOperand = true;\n    },\n    calculate() {\n      if (this.waitingForOperand || !this.expression) {\n        return;\n      }\n      \n      const value = parseFloat(this.display);\n      const fullExpression = this.expression + value;\n      \n      try {\n        // Using Function instead of eval for better security\n        const result = new Function('return ' + fullExpression.replace(/\u00d7/g, '*').replace(/\u00f7/g, '/'))();\n        this.display = Number.isInteger(result) ? result.toString() : result.toFixed(8).replace(/\\.?0+$/, '');\n        this.lastResult = result;\n        this.expression = '';\n        this.waitingForOperand = true;\n      } catch (error) {\n        this.display = 'Error';\n        this.expression = '';\n        this.lastResult = null;\n        this.waitingForOperand = true;\n      }\n    },\n    clear() {\n      this.display = '0';\n      this.expression = '';\n      this.lastResult = null;\n      this.waitingForOperand = false;\n    },\n    backspace() {\n      if (this.waitingForOperand) return;\n      \n      this.display = this.display.length > 1 ? this.display.slice(0, -1) : '0';\n    },\n    toggleSign() {\n      this.display = (parseFloat(this.display) * -1).toString();\n    },\n    \n    // Dragging functionality\n    startDrag(event) {\n      this.isDragging = true;\n      \n      const rect = this.$refs.calculatorPanel.getBoundingClientRect();\n      this.dragOffset = {\n        x: event.clientX - rect.left,\n        y: event.clientY - rect.top\n      };\n      \n      document.addEventListener('mousemove', this.onDrag);\n      document.addEventListener('mouseup', this.stopDrag);\n      \n      event.preventDefault();\n    },\n    onDrag(event) {\n      if (this.isDragging) {\n        this.position = {\n          x: event.clientX - this.dragOffset.x,\n          y: event.clientY - this.dragOffset.y\n        };\n      }\n    },\n    stopDrag() {\n      this.isDragging = false;\n      document.removeEventListener('mousemove', this.onDrag);\n      document.removeEventListener('mouseup', this.stopDrag);\n    }\n  },\n  beforeUnmount() {\n    document.removeEventListener('mousemove', this.onDrag);\n    document.removeEventListener('mouseup', this.stopDrag);\n  }\n};", "output": "This code is from `Calculator.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'ColorPicker',\n  props: {\n    initialPosition: {\n      type: Object,\n      default: () => ({ x: 100, y: 100 })\n    },\n    initialColor: {\n      type: String,\n      default: '#000000'\n    }\n  },\n  data() {\n    return {\n      currentColor: this.initialColor,\n      position: this.initialPosition,\n      isDragging: false,\n      dragOffset: { x: 0, y: 0 },\n      presetColors: [\n        '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#00FFFF', '#FF00FF',\n        '#C0C0C0', '#808080', '#800000', '#808000', '#008000', '#800080', '#008080', '#000080'\n      ]\n    };\n  },\n  computed: {\n    red: {\n      get() {\n        return parseInt(this.currentColor.slice(1, 3), 16);\n      },\n      set(value) {\n        value = Math.max(0, Math.min(255, value));\n        const r = value.toString(16).padStart(2, '0');\n        const g = this.currentColor.slice(3, 5);\n        const b = this.currentColor.slice(5, 7);\n        this.currentColor = `#${r}${g}${b}`;\n      }\n    },\n    green: {\n      get() {\n        return parseInt(this.currentColor.slice(3, 5), 16);\n      },\n      set(value) {\n        value = Math.max(0, Math.min(255, value));\n        const r = this.currentColor.slice(1, 3);\n        const g = value.toString(16).padStart(2, '0');\n        const b = this.currentColor.slice(5, 7);\n        this.currentColor = `#${r}${g}${b}`;\n      }\n    },\n    blue: {\n      get() {\n        return parseInt(this.currentColor.slice(5, 7), 16);\n      },\n      set(value) {\n        value = Math.max(0, Math.min(255, value));\n        const r = this.currentColor.slice(1, 3);\n        const g = this.currentColor.slice(3, 5);\n        const b = value.toString(16).padStart(2, '0');\n        this.currentColor = `#${r}${g}${b}`;\n      }\n    }\n  },\n  methods: {\n    copyToClipboard() {\n      navigator.clipboard.writeText(this.currentColor.toUpperCase())\n        .then(() => {\n          this.$emit('notification', {\n            type: 'success',\n            message: 'Color copied to clipboard',\n            duration: 2000\n          });\n        })\n        .catch(err => {\n          console.error('Failed to copy color: ', err);\n          this.$emit('notification', {\n            type: 'error',\n            message: 'Failed to copy color',\n            duration: 2000\n          });\n        });\n    },\n    applyColor() {\n      this.$emit('color-selected', this.currentColor);\n      this.$emit('notification', {\n        type: 'success',\n        message: 'Color applied',\n        duration: 2000\n      });\n    },\n    \n    // Dragging functionality\n    startDrag(event) {\n      this.isDragging = true;\n      \n      const rect = this.$refs.colorPickerPanel.getBoundingClientRect();\n      this.dragOffset = {\n        x: event.clientX - rect.left,\n        y: event.clientY - rect.top\n      };\n      \n      document.addEventListener('mousemove', this.onDrag);\n      document.addEventListener('mouseup', this.stopDrag);\n      \n      event.preventDefault();\n    },\n    onDrag(event) {\n      if (this.isDragging) {\n        this.position = {\n          x: event.clientX - this.dragOffset.x,\n          y: event.clientY - this.dragOffset.y\n        };\n      }\n    },\n    stopDrag() {\n      this.isDragging = false;\n      document.removeEventListener('mousemove', this.onDrag);\n      document.removeEventListener('mouseup', this.stopDrag);\n    }\n  },\n  beforeUnmount() {\n    document.removeEventListener('mousemove', this.onDrag);\n    document.removeEventListener('mouseup', this.stopDrag);\n  }\n};", "output": "This code is from `ColorPicker.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'DragHelper',\n  data() {\n    return {\n      dragData: null\n    };\n  },\n  methods: {\n    /**\n     * Initialize the drag helper\n     */\n    initialize() {\n      const dragHelper = this.$refs.dragHelper;\n      dragHelper.addEventListener('dragstart', this.handleDragStart);\n      dragHelper.addEventListener('dragend', this.handleDragEnd);\n    },\n    \n    /**\n     * Start a drag operation\n     * @param {Object} data - The data to be dragged\n     * @param {Event} event - The original event that triggered the drag\n     */\n    startDrag(data, event) {\n      console.log('DragHelper: Starting drag with data:', data);\n      this.dragData = data;\n      \n      const dragHelper = this.$refs.dragHelper;\n      dragHelper.style.display = 'block';\n      dragHelper.style.top = (event.clientY - 10) + 'px';\n      dragHelper.style.left = (event.clientX - 10) + 'px';\n      \n      // Trigger the drag programmatically\n      setTimeout(() => {\n        dragHelper.dispatchEvent(new MouseEvent('dragstart', {\n          bubbles: true,\n          cancelable: true,\n          view: window\n        }));\n      }, 10);\n    },\n    \n    /**\n     * Handle the dragstart event\n     * @param {DragEvent} event - The drag event\n     */\n    handleDragStart(event) {\n      console.log('DragHelper: Drag started');\n      if (!this.dragData) return;\n      \n      try {\n        // Set the drag data\n        event.dataTransfer.setData('application/json', JSON.stringify(this.dragData));\n        \n        // Create a drag image\n        const dragImage = document.createElement('div');\n        dragImage.textContent = this.dragData.shape ? this.dragData.shape.type : 'Shape';\n        dragImage.style.padding = '10px';\n        dragImage.style.background = '#3B82F6';\n        dragImage.style.color = 'white';\n        dragImage.style.borderRadius = '4px';\n        dragImage.style.position = 'absolute';\n        dragImage.style.top = '-1000px';\n        document.body.appendChild(dragImage);\n        \n        // Set the drag image\n        event.dataTransfer.setDragImage(dragImage, 25, 25);\n        \n        // Clean up the drag image after a short delay\n        setTimeout(() => {\n          document.body.removeChild(dragImage);\n        }, 100);\n        \n        // Set the allowed effects\n        event.dataTransfer.effectAllowed = 'copy';\n      } catch (error) {\n        console.error('DragHelper: Error setting drag data:', error);\n      }\n    },\n    \n    /**\n     * Handle the dragend event\n     */\n    handleDragEnd() {\n      console.log('DragHelper: Drag ended');\n      const dragHelper = this.$refs.dragHelper;\n      dragHelper.style.display = 'none';\n      this.dragData = null;\n    }\n  },\n  mounted() {\n    this.initialize();\n  },\n  beforeUnmount() {\n    const dragHelper = this.$refs.dragHelper;\n    if (dragHelper) {\n      dragHelper.removeEventListener('dragstart', this.handleDragStart);\n      dragHelper.removeEventListener('dragend', this.handleDragEnd);\n    }\n  }\n};", "output": "This code is from `DragHelper.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'GlossyToggle',\n  data() {\n    return {\n      isGlossy: false\n    };\n  },\n  mounted() {\n    try {\n      // Load saved preference\n      const savedPreference = localStorage.getItem('glossyUI');\n      if (savedPreference === 'true') {\n        this.isGlossy = true;\n        // Wait for DOM to be fully rendered before applying effects\n        this.$nextTick(() => {\n          this.applyGlossyEffect();\n        });\n      }\n    } catch (error) {\n      console.error('Error in GlossyToggle mounted hook:', error);\n    }\n  },\n  methods: {\n    toggleGlossy() {\n      this.isGlossy = !this.isGlossy;\n      localStorage.setItem('glossyUI', this.isGlossy);\n      \n      // Use $nextTick to ensure DOM is updated before applying/removing effects\n      this.$nextTick(() => {\n        if (this.isGlossy) {\n          this.applyGlossyEffect();\n        } else {\n          this.removeGlossyEffect();\n        }\n      });\n    },\n    \n    applyGlossyEffect() {\n      try {\n        // Apply glossy classes to elements\n        const menuBar = document.querySelector('.bg-gray-900.border-b.border-gray-800');\n        const menuButtons = document.querySelector('.flex.items-center.space-x-2');\n        const ribbon = document.querySelector('.max-w-full.mx-auto.px-4');\n        \n        if (menuBar) menuBar.classList.add('glossy-menubar');\n        if (menuButtons) menuButtons.classList.add('glossy-buttons', 'glossy-tabs');\n        if (ribbon) ribbon.classList.add('glossy-ribbon');\n      } catch (error) {\n        console.error('Error applying glossy effect:', error);\n      }\n    },\n    \n    removeGlossyEffect() {\n      try {\n        // Remove glossy classes from elements\n        const menuBar = document.querySelector('.bg-gray-900.border-b.border-gray-800');\n        const menuButtons = document.querySelector('.flex.items-center.space-x-2');\n        const ribbon = document.querySelector('.max-w-full.mx-auto.px-4');\n        \n        if (menuBar) menuBar.classList.remove('glossy-menubar');\n        if (menuButtons) menuButtons.classList.remove('glossy-buttons', 'glossy-tabs');\n        if (ribbon) ribbon.classList.remove('glossy-ribbon');\n      } catch (error) {\n        console.error('Error removing glossy effect:', error);\n      }\n    }\n  }\n};", "output": "This code is from `GlossyToggle.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nimport { useCanvasStore } from '../stores/canvasStore.js';\nimport GlossyToggle from './GlossyToggle.vue';\n\nexport default {\n  components: { GlossyToggle },\n  name: 'MenuBar',\n  setup() {\n    const store = useCanvasStore();\n    return { store };\n  },\n  data() {\n    return {\n      showFileMenu: false,\n      showHelpMenu: false,\n      fileMenuItems: [\n        { label: 'New', icon: '\ud83d\udcc4', action: 'new' },\n        { label: 'Open', icon: '\ud83d\udcc2', action: 'open' },\n        { label: 'Save', icon: '\ud83d\udcbe', action: 'save' },\n        { label: 'Save As', icon: '\ud83d\udcbe', action: 'saveAs' },\n        { label: 'Export as PDF', icon: '\ud83d\udcd1', action: 'exportPdf' },\n        { label: 'Export as PNG', icon: '\ud83d\uddbc\ufe0f', action: 'exportPng' },\n        { label: 'Export as SVG', icon: '\ud83d\udcd0', action: 'exportSvg' },\n      ],\n      helpMenuItems: [\n        { label: 'Keyboard Shortcuts', icon: '\u2328\ufe0f', action: 'keyboardShortcuts' },\n        { label: 'About', icon: '\u2139\ufe0f', action: 'about' },\n        { label: 'User Guide', icon: '\ud83d\udcd6', action: 'userGuide' },\n        { label: 'Documentation', icon: '\ud83d\udcda', action: 'docs' },\n        { label: 'Support', icon: '\ud83d\udce7', action: 'support' },\n        { label: 'Live Chat', icon: '\ud83d\udcac', action: 'liveChat' },\n      ],\n    };\n  },\n  mounted() {\n    document.addEventListener('click', this.closeMenus);\n  },\n  beforeUnmount() {\n    document.removeEventListener('click', this.closeMenus);\n  },\n  methods: {\n    closeMenus() {\n      this.showFileMenu = false;\n      this.showHelpMenu = false;\n    },\n    handleMenuAction(action) {\n      console.log('Menu action triggered:', action);\n      this.closeMenus();\n      if (action === 'userGuide') {\n        window.open('/docs/User_Guide.md', '_blank');\n      } else if (['about', 'keyboardShortcuts', 'docs', 'support', 'liveChat'].includes(action)) {\n        this.$emit('menu', { type: 'help', value: action });\n      } else {\n        this.$emit('menu', { type: 'file', value: action });\n      }\n    },\n  },\n};", "output": "This code is from `MenuBar.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'Notification',\n  props: {\n    type: {\n      type: String,\n      default: 'info',\n      validator: value => ['info', 'success', 'warning', 'error'].includes(value)\n    },\n    message: {\n      type: String,\n      required: true\n    },\n    details: {\n      type: String,\n      default: ''\n    },\n    duration: {\n      type: Number,\n      default: 5000\n    },\n    actions: {\n      type: Array,\n      default: () => []\n    },\n    top: {\n      type: Number,\n      default: 20\n    }\n  },\n  data() {\n    return {\n      show: true,\n      timeout: null\n    };\n  },\n  computed: {\n    typeClasses() {\n      switch (this.type) {\n        case 'error':\n          return 'bg-red-900 text-white border-l-4 border-red-500';\n        case 'warning':\n          return 'bg-yellow-900 text-white border-l-4 border-yellow-500';\n        case 'success':\n          return 'bg-green-900 text-white border-l-4 border-green-500';\n        default:\n          return 'bg-blue-900 text-white border-l-4 border-blue-500';\n      }\n    }\n  },\n  mounted() {\n    if (this.duration > 0) {\n      this.timeout = setTimeout(() => {\n        this.close();\n      }, this.duration);\n    }\n  },\n  beforeUnmount() {\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n    }\n  },\n  methods: {\n    close() {\n      this.show = false;\n      this.$emit('close');\n    },\n    handleAction(action) {\n      if (typeof action.callback === 'function') {\n        action.callback();\n      }\n      this.close();\n    }\n  }\n};", "output": "This code is from `Notification.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nimport Notification from './Notification.vue';\n\nexport default {\n  name: 'NotificationManager',\n  components: {\n    Notification\n  },\n  data() {\n    return {\n      notifications: [],\n      nextId: 1\n    };\n  },\n  methods: {\n    addNotification(notification) {\n      const id = this.nextId++;\n      this.notifications.push({\n        id,\n        type: notification.type || 'info',\n        message: notification.message,\n        details: notification.details || '',\n        duration: notification.duration || 5000,\n        actions: notification.actions || []\n      });\n      \n      // Limit the number of notifications to prevent overwhelming the UI\n      if (this.notifications.length > 5) {\n        this.notifications.shift();\n      }\n      \n      return id;\n    },\n    removeNotification(id) {\n      const index = this.notifications.findIndex(n => n.id === id);\n      if (index !== -1) {\n        this.notifications.splice(index, 1);\n      }\n    },\n    clearAll() {\n      this.notifications = [];\n    }\n  }\n};", "output": "This code is from `NotificationManager.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'PageManagerDialog',\n  props: {\n    show: { type: Boolean, default: false },\n    pages: { type: Array, default: () => [] },\n    activePage: { type: String, default: '' },\n    isDarkTheme: { type: Boolean, default: false }\n  },\n  data() {\n    return {\n      editingPage: null,\n      editName: ''\n    };\n  },\n  computed: {\n    backgroundPages() {\n      return this.pages.filter(page => page.type === 'background');\n    }\n  },\n  methods: {\n    startEditing(page) {\n      this.editingPage = page.id;\n      this.editName = page.name;\n      this.$nextTick(() => {\n        if (this.$refs.nameInput) {\n          this.$refs.nameInput.focus();\n        }\n      });\n    },\n    saveName(pageId) {\n      if (!this.editName.trim()) {\n        this.editName = 'Untitled Page';\n      }\n      \n      const page = this.pages.find(p => p.id === pageId);\n      if (page) {\n        page.name = this.editName.trim();\n        this.$emit('update-page', page);\n      }\n      \n      this.editingPage = null;\n    },\n    updatePage(page) {\n      this.$emit('update-page', page);\n    },\n    movePage(page, direction) {\n      this.$emit('move-page', { pageId: page.id, direction });\n    },\n    deletePage(page) {\n      if (confirm(`Are you sure you want to delete the page \"${page.name}\"?`)) {\n        this.$emit('delete-page', page.id);\n      }\n    },\n    isFirstPage(page) {\n      const index = this.pages.findIndex(p => p.id === page.id);\n      return index === 0;\n    },\n    isLastPage(page) {\n      const index = this.pages.findIndex(p => p.id === page.id);\n      return index === this.pages.length - 1;\n    },\n    isPageUsedAsBackground(page) {\n      if (page.type !== 'background') return false;\n      return this.pages.some(p => p.backgroundPageId === page.id);\n    }\n  }\n};", "output": "This code is from `PageManagerDialog.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'PartPropertiesDialog',\n  props: {\n    show: {\n      type: Boolean,\n      default: false\n    },\n    initialProperties: {\n      type: Object,\n      default: () => ({\n        name: '',\n        haystackTag: '',\n        partNumber: '',\n        quantity: 1,\n        description: '',\n        pointType: '',\n        pdfPath: ''\n      })\n    }\n  },\n  data() {\n    return {\n      localProperties: {\n        name: '',\n        haystackTag: '',\n        partNumber: '',\n        quantity: 1,\n        description: '',\n        pointType: '',\n        pdfPath: ''\n      }\n    };\n  },\n  watch: {\n    show(newVal) {\n      if (newVal) {\n        // Initialize with provided properties\n        this.localProperties = { ...this.initialProperties };\n      }\n    }\n  },\n  methods: {\n    browsePdf() {\n      this.$refs.pdfInput.click();\n    },\n    \n    handlePdfSelect(event) {\n      const file = event.target.files[0];\n      if (!file) return;\n      \n      // In a real app, you'd upload this file to a server\n      // For now, we'll just store the filename\n      this.localProperties.pdfPath = file.name;\n      \n      // Reset the input\n      event.target.value = '';\n    },\n    \n    cancel() {\n      this.$emit('cancel');\n    },\n    \n    confirm() {\n      this.$emit('confirm', { ...this.localProperties });\n    }\n  }\n};", "output": "This code is from `PartPropertiesDialog.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'Ribbon',\n  props: {\n    activeTab: {\n      type: String,\n      default: 'Home'\n    },\n    gridSize: {\n      type: Number,\n      default: 20\n    },\n    gridOpacity: {\n      type: Number,\n      default: 0.5\n    },\n    gridType: {\n      type: String,\n      default: 'square'\n    },\n    gridColor: {\n      type: String,\n      default: '#000000'\n    },\n    showLayers: {\n      type: Boolean,\n      default: false\n    },\n    showShapeLibrary: {\n      type: Boolean,\n      default: false\n    }\n  }\n}", "output": "This code is from `Ribbon.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: \"AppRulers\",\n  props: {\n    showRulers: { type: Boolean, required: true },\n    canvasWidth: { type: Number, required: true },\n    canvasHeight: { type: Number, required: true },\n    zoomLevel: { type: Number, default: 1 },\n    offsetX: { type: Number, default: 0 },\n    offsetY: { type: Number, default: 0 }\n  },\n  data() {\n    return {\n      windowWidth: window.innerWidth,\n      windowHeight: window.innerHeight\n    };\n  },\n  mounted() {\n    window.addEventListener('resize', this.updateWindowDimensions);\n  },\n  beforeUnmount() {\n    window.removeEventListener('resize', this.updateWindowDimensions);\n  },\n  methods: {\n    updateWindowDimensions() {\n      this.windowWidth = window.innerWidth;\n      this.windowHeight = window.innerHeight;\n    }\n  },\n  computed: {\n    pixelsPerInch() {\n      return 96;\n    },\n    pixelsPerQuarterInch() {\n      return this.pixelsPerInch / 4;\n    },\n    horizontalMarks() {\n      return Array.from({ length: 17 * 4 + 1 }, (_, i) => i);\n    },\n    verticalMarks() {\n      return Array.from({ length: 11 * 4 + 1 }, (_, i) => i);\n    },\n    horizontalOffset() {\n      // Calculate the horizontal offset for the ruler\n      return Math.floor(this.windowWidth / 2 - this.canvasWidth / 2);\n    },\n    verticalOffset() {\n      // Calculate the vertical offset for the ruler\n      return Math.floor((this.windowHeight - 130) / 2 - this.canvasHeight / 2);\n    }\n  }\n}", "output": "This code is from `Rulers.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'SplashScreen',\n  props: {\n    duration: {\n      type: Number,\n      default: 3000 // Duration in milliseconds\n    },\n    version: {\n      type: String,\n      default: '1.0.0'\n    },\n    licenseNumber: {\n      type: String,\n      default: ''\n    }\n  },\n  data() {\n    return {\n      visible: true,\n      fadeOut: false\n    }\n  },\n  mounted() {\n    // Start fade out animation after specified duration\n    setTimeout(() => {\n      this.fadeOut = true;\n      \n      // Hide component after animation completes\n      setTimeout(() => {\n        this.visible = false;\n        this.$emit('splash-complete');\n      }, 1000); // Animation duration\n    }, this.duration);\n  },\n  methods: {\n    getSparkleStyle(index) {\n      // Generate random positions for sparkle elements\n      const angle = (index / 5) * Math.PI * 2;\n      const distance = 100 + Math.random() * 50;\n      const delay = Math.random() * 0.5;\n      \n      return {\n        top: `calc(50% + ${Math.sin(angle) * distance}px)`,\n        left: `calc(50% + ${Math.cos(angle) * distance}px)`,\n        animationDelay: `${delay}s`\n      };\n    }\n  }\n}", "output": "This code is from `SplashScreen.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
{"input": "What does the following code do?\n\nexport default {\n  name: 'ToolFlyout',\n  data: () => ({\n    shapes: [\n      { name: 'rect', label: 'Rectangle' },\n      { name: 'circle', label: 'Circle' },\n      { name: 'arrow', label: 'Arrow' },\n      { name: 'diamond', label: 'Decision' }\n    ]\n  }),\n  methods: {\n    selectShape(shape) {\n      this.$emit('shape-selected', shape.name);\n    },\n    getShapeIcon(shapeName) {\n      // Simple SVG icons as strings\n      const icons = {\n        rect: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                <rect x=\"3\" y=\"5\" width=\"18\" height=\"14\" rx=\"2\" />\n              </svg>`,\n        circle: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                  <circle cx=\"12\" cy=\"12\" r=\"9\" />\n                </svg>`,\n        arrow: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                 <line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\" />\n                 <polyline points=\"12 5 19 12 12 19\" />\n               </svg>`,\n        diamond: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                   <polygon points=\"12 2 22 12 12 22 2 12\" />\n                 </svg>`\n      };\n      \n      return icons[shapeName] || icons.rect;\n    }\n  }\n}", "output": "This code is from `ToolFlyout.vue`. It defines logic in the CtrlSketch application. (Explanation placeholder)"}
